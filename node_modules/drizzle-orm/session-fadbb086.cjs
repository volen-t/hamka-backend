'use strict';

var index$1 = require('./index-b1dbb7ec.cjs');

var _a$m, _b$j, _c$9;
/** @internal */
const InlineForeignKeys = Symbol.for('drizzle:SQLiteInlineForeignKeys');
class SQLiteTable extends index$1.Table {
    constructor() {
        super(...arguments);
        /** @internal */
        this[_b$j] = [];
        /** @internal */
        this[_c$9] = undefined;
    }
}
_a$m = index$1.entityKind, index$1.Table.Symbol.Columns, _b$j = InlineForeignKeys, _c$9 = index$1.Table.Symbol.ExtraConfigBuilder;
SQLiteTable[_a$m] = 'SQLiteTable';
/** @internal */
SQLiteTable.Symbol = Object.assign({}, index$1.Table.Symbol, {
    InlineForeignKeys: InlineForeignKeys,
});
function sqliteTableBase(name, columns, extraConfig, schema, baseName = name) {
    const rawTable = new SQLiteTable(name, schema, baseName);
    const builtColumns = Object.fromEntries(Object.entries(columns).map(([name, colBuilderBase]) => {
        const colBuilder = colBuilderBase;
        const column = colBuilder.build(rawTable);
        rawTable[InlineForeignKeys].push(...colBuilder.buildForeignKeys(column, rawTable));
        return [name, column];
    }));
    const table = Object.assign(rawTable, builtColumns);
    table[index$1.Table.Symbol.Columns] = builtColumns;
    if (extraConfig) {
        table[SQLiteTable.Symbol.ExtraConfigBuilder] = extraConfig;
    }
    return table;
}
const sqliteTable = (name, columns, extraConfig) => {
    return sqliteTableBase(name, columns, extraConfig);
};
function sqliteTableCreator(customizeTableName) {
    return (name, columns, extraConfig) => {
        return sqliteTableBase(customizeTableName(name), columns, extraConfig, undefined, name);
    };
}

var _a$l;
class SQLiteDelete extends index$1.QueryPromise {
    constructor(table, session, dialect) {
        super();
        this.table = table;
        this.session = session;
        this.dialect = dialect;
        this.run = (placeholderValues) => {
            return this.prepare(true).run(placeholderValues);
        };
        this.all = (placeholderValues) => {
            return this.prepare(true).all(placeholderValues);
        };
        this.get = (placeholderValues) => {
            return this.prepare(true).get(placeholderValues);
        };
        this.values = (placeholderValues) => {
            return this.prepare(true).values(placeholderValues);
        };
        this.config = { table };
    }
    where(where) {
        this.config.where = where;
        return this;
    }
    returning(fields = this.table[SQLiteTable.Symbol.Columns]) {
        this.config.returning = index$1.orderSelectedFields(fields);
        return this;
    }
    /** @internal */
    getSQL() {
        return this.dialect.buildDeleteQuery(this.config);
    }
    toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
    }
    prepare(isOneTimeQuery) {
        return this.session[isOneTimeQuery ? 'prepareOneTimeQuery' : 'prepareQuery'](this.dialect.sqlToQuery(this.getSQL()), this.config.returning, this.config.returning ? 'all' : 'run');
    }
    async execute(placeholderValues) {
        return this.prepare(true).execute(placeholderValues);
    }
}
_a$l = index$1.entityKind;
SQLiteDelete[_a$l] = 'SQLiteDelete';

var _a$k, _b$i;
class SQLiteInsertBuilder {
    constructor(table, session, dialect) {
        this.table = table;
        this.session = session;
        this.dialect = dialect;
    }
    values(values) {
        values = Array.isArray(values) ? values : [values];
        if (values.length === 0) {
            throw new Error('values() must be called with at least one value');
        }
        const mappedValues = values.map((entry) => {
            const result = {};
            const cols = this.table[index$1.Table.Symbol.Columns];
            for (const colKey of Object.keys(entry)) {
                const colValue = entry[colKey];
                result[colKey] = index$1.is(colValue, index$1.SQL) ? colValue : new index$1.Param(colValue, cols[colKey]);
            }
            return result;
        });
        // if (mappedValues.length > 1 && mappedValues.some((t) => Object.keys(t).length === 0)) {
        // 	throw new Error(
        // 		`One of the values you want to insert is empty. In SQLite you can insert only one empty object per statement. For this case Drizzle with use "INSERT INTO ... DEFAULT VALUES" syntax`,
        // 	);
        // }
        return new SQLiteInsert(this.table, mappedValues, this.session, this.dialect);
    }
}
_a$k = index$1.entityKind;
SQLiteInsertBuilder[_a$k] = 'SQLiteInsertBuilder';
class SQLiteInsert extends index$1.QueryPromise {
    constructor(table, values, session, dialect) {
        super();
        this.session = session;
        this.dialect = dialect;
        this.run = (placeholderValues) => {
            return this.prepare(true).run(placeholderValues);
        };
        this.all = (placeholderValues) => {
            return this.prepare(true).all(placeholderValues);
        };
        this.get = (placeholderValues) => {
            return this.prepare(true).get(placeholderValues);
        };
        this.values = (placeholderValues) => {
            return this.prepare(true).values(placeholderValues);
        };
        this.config = { table, values };
    }
    returning(fields = this.config.table[SQLiteTable.Symbol.Columns]) {
        this.config.returning = index$1.orderSelectedFields(fields);
        return this;
    }
    onConflictDoNothing(config = {}) {
        if (config.target === undefined) {
            this.config.onConflict = index$1.sql `do nothing`;
        }
        else {
            const targetSql = Array.isArray(config.target) ? index$1.sql `${config.target}` : index$1.sql `${[config.target]}`;
            const whereSql = config.where ? index$1.sql ` where ${config.where}` : index$1.sql ``;
            this.config.onConflict = index$1.sql `${targetSql}${whereSql} do nothing`;
        }
        return this;
    }
    onConflictDoUpdate(config) {
        const targetSql = Array.isArray(config.target) ? index$1.sql `${config.target}` : index$1.sql `${[config.target]}`;
        const whereSql = config.where ? index$1.sql ` where ${config.where}` : index$1.sql ``;
        const setSql = this.dialect.buildUpdateSet(this.config.table, index$1.mapUpdateSet(this.config.table, config.set));
        this.config.onConflict = index$1.sql `${targetSql}${whereSql} do update set ${setSql}`;
        return this;
    }
    /** @internal */
    getSQL() {
        return this.dialect.buildInsertQuery(this.config);
    }
    toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
    }
    prepare(isOneTimeQuery) {
        return this.session[isOneTimeQuery ? 'prepareOneTimeQuery' : 'prepareQuery'](this.dialect.sqlToQuery(this.getSQL()), this.config.returning, this.config.returning ? 'all' : 'run');
    }
    async execute() {
        return (this.config.returning ? this.all() : this.run());
    }
}
_b$i = index$1.entityKind;
SQLiteInsert[_b$i] = 'SQLiteInsert';

var _a$j, _b$h;
class ForeignKeyBuilder {
    constructor(config, actions) {
        this.reference = () => {
            const { columns, foreignColumns } = config();
            return { columns, foreignTable: foreignColumns[0].table, foreignColumns };
        };
        if (actions) {
            this._onUpdate = actions.onUpdate;
            this._onDelete = actions.onDelete;
        }
    }
    onUpdate(action) {
        this._onUpdate = action;
        return this;
    }
    onDelete(action) {
        this._onDelete = action;
        return this;
    }
    /** @internal */
    build(table) {
        return new ForeignKey(table, this);
    }
}
_a$j = index$1.entityKind;
ForeignKeyBuilder[_a$j] = 'SQLiteForeignKeyBuilder';
class ForeignKey {
    constructor(table, builder) {
        this.table = table;
        this.reference = builder.reference;
        this.onUpdate = builder._onUpdate;
        this.onDelete = builder._onDelete;
    }
    getName() {
        const { columns, foreignColumns } = this.reference();
        const columnNames = columns.map((column) => column.name);
        const foreignColumnNames = foreignColumns.map((column) => column.name);
        const chunks = [
            this.table[SQLiteTable.Symbol.Name],
            ...columnNames,
            foreignColumns[0].table[SQLiteTable.Symbol.Name],
            ...foreignColumnNames,
        ];
        return `${chunks.join('_')}_fk`;
    }
}
_b$h = index$1.entityKind;
ForeignKey[_b$h] = 'SQLiteForeignKey';
function foreignKey(config) {
    function mappedConfig() {
        const { columns, foreignColumns } = config();
        return {
            columns,
            foreignColumns,
        };
    }
    return new ForeignKeyBuilder(mappedConfig);
}

var _a$i, _b$g, _c$8;
function uniqueKeyName(table, columns) {
    return `${table[SQLiteTable.Symbol.Name]}_${columns.join('_')}_unique`;
}
function unique(name) {
    return new UniqueOnConstraintBuilder(name);
}
class UniqueConstraintBuilder {
    constructor(columns, name) {
        this.name = name;
        this.columns = columns;
    }
    /** @internal */
    build(table) {
        return new UniqueConstraint(table, this.columns, this.name);
    }
}
_a$i = index$1.entityKind;
UniqueConstraintBuilder[_a$i] = 'SQLiteUniqueConstraintBuilder';
class UniqueOnConstraintBuilder {
    constructor(name) {
        this.name = name;
    }
    on(...columns) {
        return new UniqueConstraintBuilder(columns, this.name);
    }
}
_b$g = index$1.entityKind;
UniqueOnConstraintBuilder[_b$g] = 'SQLiteUniqueOnConstraintBuilder';
class UniqueConstraint {
    constructor(table, columns, name) {
        this.table = table;
        this.columns = columns;
        this.name = name ?? uniqueKeyName(this.table, this.columns.map((column) => column.name));
    }
    getName() {
        return this.name;
    }
}
_c$8 = index$1.entityKind;
UniqueConstraint[_c$8] = 'SQLiteUniqueConstraint';

var _a$h, _b$f;
class SQLiteColumnBuilder extends index$1.ColumnBuilder {
    constructor() {
        super(...arguments);
        this.foreignKeyConfigs = [];
    }
    references(ref, actions = {}) {
        this.foreignKeyConfigs.push({ ref, actions });
        return this;
    }
    unique(name) {
        this.config.isUnique = true;
        this.config.uniqueName = name;
        return this;
    }
    /** @internal */
    buildForeignKeys(column, table) {
        return this.foreignKeyConfigs.map(({ ref, actions }) => {
            return ((ref, actions) => {
                const builder = new ForeignKeyBuilder(() => {
                    const foreignColumn = ref();
                    return { columns: [column], foreignColumns: [foreignColumn] };
                });
                if (actions.onUpdate) {
                    builder.onUpdate(actions.onUpdate);
                }
                if (actions.onDelete) {
                    builder.onDelete(actions.onDelete);
                }
                return builder.build(table);
            })(ref, actions);
        });
    }
}
_a$h = index$1.entityKind;
SQLiteColumnBuilder[_a$h] = 'SQLiteColumnBuilder';
// To understand how to use `SQLiteColumn` and `AnySQLiteColumn`, see `Column` and `AnyColumn` documentation.
class SQLiteColumn extends index$1.Column {
    constructor(table, config) {
        if (!config.uniqueName) {
            config.uniqueName = uniqueKeyName(table, [config.name]);
        }
        super(table, config);
        this.table = table;
    }
}
_b$f = index$1.entityKind;
SQLiteColumn[_b$f] = 'SQLiteColumn';

var _a$g, _b$e, _c$7, _d$3, _e$2, _f$1;
class SQLiteBigIntBuilder extends SQLiteColumnBuilder {
    constructor(name) {
        super(name, 'bigint', 'SQLiteBigInt');
    }
    /** @internal */
    build(table) {
        return new SQLiteBigInt(table, this.config);
    }
}
_a$g = index$1.entityKind;
SQLiteBigIntBuilder[_a$g] = 'SQLiteBigIntBuilder';
class SQLiteBigInt extends SQLiteColumn {
    getSQLType() {
        return 'blob';
    }
    mapFromDriverValue(value) {
        return BigInt(value.toString());
    }
    mapToDriverValue(value) {
        return Buffer.from(value.toString());
    }
}
_b$e = index$1.entityKind;
SQLiteBigInt[_b$e] = 'SQLiteBigInt';
class SQLiteBlobJsonBuilder extends SQLiteColumnBuilder {
    constructor(name) {
        super(name, 'json', 'SQLiteBlobJson');
    }
    /** @internal */
    build(table) {
        return new SQLiteBlobJson(table, this.config);
    }
}
_c$7 = index$1.entityKind;
SQLiteBlobJsonBuilder[_c$7] = 'SQLiteBlobJsonBuilder';
class SQLiteBlobJson extends SQLiteColumn {
    getSQLType() {
        return 'blob';
    }
    mapFromDriverValue(value) {
        return JSON.parse(value.toString());
    }
    mapToDriverValue(value) {
        return Buffer.from(JSON.stringify(value));
    }
}
_d$3 = index$1.entityKind;
SQLiteBlobJson[_d$3] = 'SQLiteBlobJson';
class SQLiteBlobBufferBuilder extends SQLiteColumnBuilder {
    constructor(name) {
        super(name, 'buffer', 'SQLiteBlobBuffer');
    }
    /** @internal */
    build(table) {
        return new SQLiteBlobBuffer(table, this.config);
    }
}
_e$2 = index$1.entityKind;
SQLiteBlobBufferBuilder[_e$2] = 'SQLiteBlobBufferBuilder';
class SQLiteBlobBuffer extends SQLiteColumn {
    getSQLType() {
        return 'blob';
    }
}
_f$1 = index$1.entityKind;
SQLiteBlobBuffer[_f$1] = 'SQLiteBlobBuffer';
function blob(name, config) {
    if (config?.mode === 'json') {
        return new SQLiteBlobJsonBuilder(name);
    }
    if (config?.mode === 'bigint') {
        return new SQLiteBigIntBuilder(name);
    }
    return new SQLiteBlobBufferBuilder(name);
}

var _a$f, _b$d;
class SQLiteCustomColumnBuilder extends SQLiteColumnBuilder {
    constructor(name, fieldConfig, customTypeParams) {
        super(name, 'custom', 'SQLiteCustomColumn');
        this.config.fieldConfig = fieldConfig;
        this.config.customTypeParams = customTypeParams;
    }
    /** @internal */
    build(table) {
        return new SQLiteCustomColumn(table, this.config);
    }
}
_a$f = index$1.entityKind;
SQLiteCustomColumnBuilder[_a$f] = 'SQLiteCustomColumnBuilder';
class SQLiteCustomColumn extends SQLiteColumn {
    constructor(table, config) {
        super(table, config);
        this.sqlName = config.customTypeParams.dataType(config.fieldConfig);
        this.mapTo = config.customTypeParams.toDriver;
        this.mapFrom = config.customTypeParams.fromDriver;
    }
    getSQLType() {
        return this.sqlName;
    }
    mapFromDriverValue(value) {
        return typeof this.mapFrom === 'function' ? this.mapFrom(value) : value;
    }
    mapToDriverValue(value) {
        return typeof this.mapTo === 'function' ? this.mapTo(value) : value;
    }
}
_b$d = index$1.entityKind;
SQLiteCustomColumn[_b$d] = 'SQLiteCustomColumn';
/**
 * Custom sqlite database data type generator
 */
function customType(customTypeParams) {
    return (dbName, fieldConfig) => {
        return new SQLiteCustomColumnBuilder(dbName, fieldConfig, customTypeParams);
    };
}

var _a$e, _b$c, _c$6, _d$2, _e$1, _f, _g, _h;
class SQLiteBaseIntegerBuilder extends SQLiteColumnBuilder {
    constructor(name, dataType, columnType) {
        super(name, dataType, columnType);
        this.config.autoIncrement = false;
    }
    primaryKey(config) {
        if (config?.autoIncrement) {
            this.config.autoIncrement = true;
        }
        this.config.hasDefault = true;
        return super.primaryKey();
    }
}
_a$e = index$1.entityKind;
SQLiteBaseIntegerBuilder[_a$e] = 'SQLiteBaseIntegerBuilder';
class SQLiteBaseInteger extends SQLiteColumn {
    constructor() {
        super(...arguments);
        this.autoIncrement = this.config.autoIncrement;
    }
    getSQLType() {
        return 'integer';
    }
}
_b$c = index$1.entityKind;
SQLiteBaseInteger[_b$c] = 'SQLiteBaseInteger';
class SQLiteIntegerBuilder extends SQLiteBaseIntegerBuilder {
    constructor(name) {
        super(name, 'number', 'SQLiteInteger');
    }
    build(table) {
        return new SQLiteInteger(table, this.config);
    }
}
_c$6 = index$1.entityKind;
SQLiteIntegerBuilder[_c$6] = 'SQLiteIntegerBuilder';
class SQLiteInteger extends SQLiteBaseInteger {
}
_d$2 = index$1.entityKind;
SQLiteInteger[_d$2] = 'SQLiteInteger';
class SQLiteTimestampBuilder extends SQLiteBaseIntegerBuilder {
    constructor(name, mode) {
        super(name, 'date', 'SQLiteTimestamp');
        this.config.mode = mode;
    }
    /**
     * @deprecated Use `default()` with your own expression instead.
     *
     * Adds `DEFAULT (cast((julianday('now') - 2440587.5)*86400000 as integer))` to the column, which is the current epoch timestamp in milliseconds.
     */
    defaultNow() {
        return this.default(index$1.sql `(cast((julianday('now') - 2440587.5)*86400000 as integer))`);
    }
    build(table) {
        return new SQLiteTimestamp(table, this.config);
    }
}
_e$1 = index$1.entityKind;
SQLiteTimestampBuilder[_e$1] = 'SQLiteTimestampBuilder';
class SQLiteTimestamp extends SQLiteBaseInteger {
    constructor() {
        super(...arguments);
        this.mode = this.config.mode;
    }
    mapFromDriverValue(value) {
        if (this.config.mode === 'timestamp') {
            return new Date(value * 1000);
        }
        return new Date(value);
    }
    mapToDriverValue(value) {
        const unix = value.getTime();
        if (this.config.mode === 'timestamp') {
            return Math.floor(unix / 1000);
        }
        return unix;
    }
}
_f = index$1.entityKind;
SQLiteTimestamp[_f] = 'SQLiteTimestamp';
class SQLiteBooleanBuilder extends SQLiteBaseIntegerBuilder {
    constructor(name, mode) {
        super(name, 'boolean', 'SQLiteBoolean');
        this.config.mode = mode;
    }
    build(table) {
        return new SQLiteBoolean(table, this.config);
    }
}
_g = index$1.entityKind;
SQLiteBooleanBuilder[_g] = 'SQLiteBooleanBuilder';
class SQLiteBoolean extends SQLiteBaseInteger {
    constructor() {
        super(...arguments);
        this.mode = this.config.mode;
    }
    mapFromDriverValue(value) {
        return Number(value) === 1;
    }
    mapToDriverValue(value) {
        return value ? 1 : 0;
    }
}
_h = index$1.entityKind;
SQLiteBoolean[_h] = 'SQLiteBoolean';
function integer(name, config) {
    if (config?.mode === 'timestamp' || config?.mode === 'timestamp_ms') {
        return new SQLiteTimestampBuilder(name, config.mode);
    }
    if (config?.mode === 'boolean') {
        return new SQLiteBooleanBuilder(name, config.mode);
    }
    return new SQLiteIntegerBuilder(name);
}
const int = integer;

var _a$d, _b$b;
class SQLiteNumericBuilder extends SQLiteColumnBuilder {
    constructor(name) {
        super(name, 'string', 'SQLiteNumeric');
    }
    /** @internal */
    build(table) {
        return new SQLiteNumeric(table, this.config);
    }
}
_a$d = index$1.entityKind;
SQLiteNumericBuilder[_a$d] = 'SQLiteNumericBuilder';
class SQLiteNumeric extends SQLiteColumn {
    getSQLType() {
        return 'numeric';
    }
}
_b$b = index$1.entityKind;
SQLiteNumeric[_b$b] = 'SQLiteNumeric';
function numeric(name) {
    return new SQLiteNumericBuilder(name);
}

var _a$c, _b$a;
class SQLiteRealBuilder extends SQLiteColumnBuilder {
    constructor(name) {
        super(name, 'number', 'SQLiteReal');
    }
    /** @internal */
    build(table) {
        return new SQLiteReal(table, this.config);
    }
}
_a$c = index$1.entityKind;
SQLiteRealBuilder[_a$c] = 'SQLiteRealBuilder';
class SQLiteReal extends SQLiteColumn {
    getSQLType() {
        return 'real';
    }
}
_b$a = index$1.entityKind;
SQLiteReal[_b$a] = 'SQLiteReal';
function real(name) {
    return new SQLiteRealBuilder(name);
}

var _a$b, _b$9;
class SQLiteTextBuilder extends SQLiteColumnBuilder {
    constructor(name, config) {
        super(name, 'string', 'SQLiteText');
        this.config.enumValues = config.enum;
        this.config.length = config.length;
    }
    /** @internal */
    build(table) {
        return new SQLiteText(table, this.config);
    }
}
_a$b = index$1.entityKind;
SQLiteTextBuilder[_a$b] = 'SQLiteTextBuilder';
class SQLiteText extends SQLiteColumn {
    constructor(table, config) {
        super(table, config);
        this.enumValues = this.config.enumValues;
        this.length = this.config.length;
    }
    getSQLType() {
        return `text${this.config.length ? `(${this.config.length})` : ''}`;
    }
}
_b$9 = index$1.entityKind;
SQLiteText[_b$9] = 'SQLiteText';
function text(name, config = {}) {
    return new SQLiteTextBuilder(name, config);
}

var _a$a, _b$8, _c$5, _d$1, _e;
class ViewBuilderCore {
    constructor(name) {
        this.name = name;
        this.config = {};
    }
}
_a$a = index$1.entityKind;
ViewBuilderCore[_a$a] = 'SQLiteViewBuilderCore';
class ViewBuilder extends ViewBuilderCore {
    as(qb) {
        if (typeof qb === 'function') {
            qb = qb(new QueryBuilder());
        }
        const selectionProxy = new index$1.SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: 'error',
            sqlAliasedBehavior: 'alias',
            replaceOriginalName: true,
        });
        // const aliasedSelectedFields = new Proxy(qb.getSelectedFields(), selectionProxy);
        const aliasedSelectedFields = qb.getSelectedFields();
        return new Proxy(new SQLiteView({
            sqliteConfig: this.config,
            config: {
                name: this.name,
                schema: undefined,
                selectedFields: aliasedSelectedFields,
                query: qb.getSQL().inlineParams(),
            },
        }), selectionProxy);
    }
}
_b$8 = index$1.entityKind;
ViewBuilder[_b$8] = 'SQLiteViewBuilder';
class ManualViewBuilder extends ViewBuilderCore {
    constructor(name, columns) {
        super(name);
        this.columns = index$1.getTableColumns(sqliteTable(name, columns));
    }
    existing() {
        return new Proxy(new SQLiteView({
            sqliteConfig: undefined,
            config: {
                name: this.name,
                schema: undefined,
                selectedFields: this.columns,
                query: undefined,
            },
        }), new index$1.SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: 'error',
            sqlAliasedBehavior: 'alias',
            replaceOriginalName: true,
        }));
    }
    as(query) {
        return new Proxy(new SQLiteView({
            sqliteConfig: this.config,
            config: {
                name: this.name,
                schema: undefined,
                selectedFields: this.columns,
                query: query.inlineParams(),
            },
        }), new index$1.SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: 'error',
            sqlAliasedBehavior: 'alias',
            replaceOriginalName: true,
        }));
    }
}
_c$5 = index$1.entityKind;
ManualViewBuilder[_c$5] = 'SQLiteManualViewBuilder';
class SQLiteViewBase extends index$1.View {
}
_d$1 = index$1.entityKind;
SQLiteViewBase[_d$1] = 'SQLiteViewBase';
const SQLiteViewConfig = Symbol.for('drizzle:SQLiteViewConfig');
class SQLiteView extends SQLiteViewBase {
    constructor({ sqliteConfig, config }) {
        super(config);
        this[SQLiteViewConfig] = sqliteConfig;
    }
}
_e = index$1.entityKind;
SQLiteView[_e] = 'SQLiteView';
function sqliteView(name, selection) {
    if (selection) {
        return new ManualViewBuilder(name, selection);
    }
    return new ViewBuilder(name);
}
const view = sqliteView;

var _a$9, _b$7, _c$4;
class SQLiteDialect {
    escapeName(name) {
        return `"${name}"`;
    }
    escapeParam(_num) {
        return '?';
    }
    escapeString(str) {
        return `'${str.replace(/'/g, "''")}'`;
    }
    buildDeleteQuery({ table, where, returning }) {
        const returningSql = returning
            ? index$1.sql ` returning ${this.buildSelection(returning, { isSingleTable: true })}`
            : undefined;
        const whereSql = where ? index$1.sql ` where ${where}` : undefined;
        return index$1.sql `delete from ${table}${whereSql}${returningSql}`;
    }
    buildUpdateSet(table, set) {
        const setEntries = Object.entries(set);
        const setSize = setEntries.length;
        return index$1.sql.join(setEntries
            .flatMap(([colName, value], i) => {
            const col = table[index$1.Table.Symbol.Columns][colName];
            const res = index$1.sql `${index$1.sql.identifier(col.name)} = ${value}`;
            if (i < setSize - 1) {
                return [res, index$1.sql.raw(', ')];
            }
            return [res];
        }));
    }
    buildUpdateQuery({ table, set, where, returning }) {
        const setSql = this.buildUpdateSet(table, set);
        const returningSql = returning
            ? index$1.sql ` returning ${this.buildSelection(returning, { isSingleTable: true })}`
            : undefined;
        const whereSql = where ? index$1.sql ` where ${where}` : undefined;
        return index$1.sql `update ${table} set ${setSql}${whereSql}${returningSql}`;
    }
    /**
     * Builds selection SQL with provided fields/expressions
     *
     * Examples:
     *
     * `select <selection> from`
     *
     * `insert ... returning <selection>`
     *
     * If `isSingleTable` is true, then columns won't be prefixed with table name
     */
    buildSelection(fields, { isSingleTable = false } = {}) {
        const columnsLen = fields.length;
        const chunks = fields
            .flatMap(({ field }, i) => {
            const chunk = [];
            if (index$1.is(field, index$1.SQL.Aliased) && field.isSelectionField) {
                chunk.push(index$1.sql.identifier(field.fieldAlias));
            }
            else if (index$1.is(field, index$1.SQL.Aliased) || index$1.is(field, index$1.SQL)) {
                const query = index$1.is(field, index$1.SQL.Aliased) ? field.sql : field;
                if (isSingleTable) {
                    chunk.push(new index$1.SQL(query.queryChunks.map((c) => {
                        if (index$1.is(c, index$1.Column)) {
                            return index$1.sql.identifier(c.name);
                        }
                        return c;
                    })));
                }
                else {
                    chunk.push(query);
                }
                if (index$1.is(field, index$1.SQL.Aliased)) {
                    chunk.push(index$1.sql ` as ${index$1.sql.identifier(field.fieldAlias)}`);
                }
            }
            else if (index$1.is(field, index$1.Column)) {
                const tableName = field.table[index$1.Table.Symbol.Name];
                const columnName = field.name;
                if (isSingleTable) {
                    chunk.push(index$1.sql.identifier(columnName));
                }
                else {
                    chunk.push(index$1.sql `${index$1.sql.identifier(tableName)}.${index$1.sql.identifier(columnName)}`);
                }
            }
            if (i < columnsLen - 1) {
                chunk.push(index$1.sql `, `);
            }
            return chunk;
        });
        return index$1.sql.join(chunks);
    }
    buildSelectQuery({ withList, fields, fieldsFlat, where, having, table, joins, orderBy, groupBy, limit, offset, distinct }) {
        const fieldsList = fieldsFlat ?? index$1.orderSelectedFields(fields);
        for (const f of fieldsList) {
            if (index$1.is(f.field, index$1.Column)
                && index$1.getTableName(f.field.table)
                    !== (index$1.is(table, index$1.Subquery)
                        ? table[index$1.SubqueryConfig].alias
                        : index$1.is(table, SQLiteViewBase)
                            ? table[index$1.ViewBaseConfig].name
                            : index$1.is(table, index$1.SQL)
                                ? undefined
                                : index$1.getTableName(table))
                && !((table) => joins?.some(({ alias }) => alias === (table[index$1.Table.Symbol.IsAlias] ? index$1.getTableName(table) : table[index$1.Table.Symbol.BaseName])))(f.field.table)) {
                const tableName = index$1.getTableName(f.field.table);
                throw new Error(`Your "${f.path.join('->')}" field references a column "${tableName}"."${f.field.name}", but the table "${tableName}" is not part of the query! Did you forget to join it?`);
            }
        }
        const isSingleTable = !joins || joins.length === 0;
        let withSql;
        if (withList?.length) {
            const withSqlChunks = [index$1.sql `with `];
            for (const [i, w] of withList.entries()) {
                withSqlChunks.push(index$1.sql `${index$1.sql.identifier(w[index$1.SubqueryConfig].alias)} as (${w[index$1.SubqueryConfig].sql})`);
                if (i < withList.length - 1) {
                    withSqlChunks.push(index$1.sql `, `);
                }
            }
            withSqlChunks.push(index$1.sql ` `);
            withSql = index$1.sql.join(withSqlChunks);
        }
        const distinctSql = distinct ? index$1.sql ` distinct` : undefined;
        const selection = this.buildSelection(fieldsList, { isSingleTable });
        const tableSql = (() => {
            if (index$1.is(table, index$1.Table) && table[index$1.Table.Symbol.OriginalName] !== table[index$1.Table.Symbol.Name]) {
                return index$1.sql `${index$1.sql.identifier(table[index$1.Table.Symbol.OriginalName])} ${index$1.sql.identifier(table[index$1.Table.Symbol.Name])}`;
            }
            return table;
        })();
        const joinsArray = [];
        if (joins) {
            for (const [index, joinMeta] of joins.entries()) {
                if (index === 0) {
                    joinsArray.push(index$1.sql ` `);
                }
                const table = joinMeta.table;
                if (index$1.is(table, SQLiteTable)) {
                    const tableName = table[SQLiteTable.Symbol.Name];
                    const tableSchema = table[SQLiteTable.Symbol.Schema];
                    const origTableName = table[SQLiteTable.Symbol.OriginalName];
                    const alias = tableName === origTableName ? undefined : joinMeta.alias;
                    joinsArray.push(index$1.sql `${index$1.sql.raw(joinMeta.joinType)} join ${tableSchema ? index$1.sql `${index$1.sql.identifier(tableSchema)}.` : undefined}${index$1.sql.identifier(origTableName)}${alias && index$1.sql ` ${index$1.sql.identifier(alias)}`} on ${joinMeta.on}`);
                }
                else {
                    joinsArray.push(index$1.sql `${index$1.sql.raw(joinMeta.joinType)} join ${table} on ${joinMeta.on}`);
                }
                if (index < joins.length - 1) {
                    joinsArray.push(index$1.sql ` `);
                }
            }
        }
        const joinsSql = index$1.sql.join(joinsArray);
        const whereSql = where ? index$1.sql ` where ${where}` : undefined;
        const havingSql = having ? index$1.sql ` having ${having}` : undefined;
        const orderByList = [];
        if (orderBy) {
            for (const [index, orderByValue] of orderBy.entries()) {
                orderByList.push(orderByValue);
                if (index < orderBy.length - 1) {
                    orderByList.push(index$1.sql `, `);
                }
            }
        }
        const groupByList = [];
        if (groupBy) {
            for (const [index, groupByValue] of groupBy.entries()) {
                groupByList.push(groupByValue);
                if (index < groupBy.length - 1) {
                    groupByList.push(index$1.sql `, `);
                }
            }
        }
        const groupBySql = groupByList.length > 0 ? index$1.sql ` group by ${index$1.sql.join(groupByList)}` : undefined;
        const orderBySql = orderByList.length > 0 ? index$1.sql ` order by ${index$1.sql.join(orderByList)}` : undefined;
        const limitSql = limit ? index$1.sql ` limit ${limit}` : undefined;
        const offsetSql = offset ? index$1.sql ` offset ${offset}` : undefined;
        return index$1.sql `${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}`;
    }
    buildInsertQuery({ table, values, onConflict, returning }) {
        // const isSingleValue = values.length === 1;
        const valuesSqlList = [];
        const columns = table[index$1.Table.Symbol.Columns];
        const colEntries = Object.entries(columns);
        const insertOrder = colEntries.map(([, column]) => index$1.sql.identifier(column.name));
        for (const [valueIndex, value] of values.entries()) {
            const valueList = [];
            for (const [fieldName, col] of colEntries) {
                const colValue = value[fieldName];
                if (colValue === undefined || (index$1.is(colValue, index$1.Param) && colValue.value === undefined)) {
                    let defaultValue;
                    if (col.default !== null && col.default !== undefined) {
                        defaultValue = index$1.is(col.default, index$1.SQL) ? col.default : index$1.sql.param(col.default, col);
                        // eslint-disable-next-line unicorn/no-negated-condition
                    }
                    else if (col.defaultFn !== undefined) {
                        const defaultFnResult = col.defaultFn();
                        defaultValue = index$1.is(defaultFnResult, index$1.SQL) ? defaultFnResult : index$1.sql.param(defaultFnResult, col);
                    }
                    else {
                        defaultValue = index$1.sql `null`;
                    }
                    valueList.push(defaultValue);
                }
                else {
                    valueList.push(colValue);
                }
            }
            valuesSqlList.push(valueList);
            if (valueIndex < values.length - 1) {
                valuesSqlList.push(index$1.sql `, `);
            }
        }
        const valuesSql = index$1.sql.join(valuesSqlList);
        const returningSql = returning
            ? index$1.sql ` returning ${this.buildSelection(returning, { isSingleTable: true })}`
            : undefined;
        const onConflictSql = onConflict ? index$1.sql ` on conflict ${onConflict}` : undefined;
        // if (isSingleValue && valuesSqlList.length === 0){
        // 	return sql`insert into ${table} default values ${onConflictSql}${returningSql}`;
        // }
        return index$1.sql `insert into ${table} ${insertOrder} values ${valuesSql}${onConflictSql}${returningSql}`;
    }
    sqlToQuery(sql) {
        return sql.toQuery({
            escapeName: this.escapeName,
            escapeParam: this.escapeParam,
            escapeString: this.escapeString,
        });
    }
    buildRelationalQuery({ fullSchema, schema, tableNamesMap, table, tableConfig, queryConfig: config, tableAlias, nestedQueryRelation, joinOn, }) {
        let selection = [];
        let limit, offset, orderBy = [], where;
        const joins = [];
        if (config === true) {
            const selectionEntries = Object.entries(tableConfig.columns);
            selection = selectionEntries.map(([key, value]) => ({
                dbKey: value.name,
                tsKey: key,
                field: index$1.aliasedTableColumn(value, tableAlias),
                relationTableTsKey: undefined,
                isJson: false,
                selection: [],
            }));
        }
        else {
            const aliasedColumns = Object.fromEntries(Object.entries(tableConfig.columns).map(([key, value]) => [key, index$1.aliasedTableColumn(value, tableAlias)]));
            if (config.where) {
                const whereSql = typeof config.where === 'function'
                    ? config.where(aliasedColumns, index$1.getOperators())
                    : config.where;
                where = whereSql && index$1.mapColumnsInSQLToAlias(whereSql, tableAlias);
            }
            const fieldsSelection = [];
            let selectedColumns = [];
            // Figure out which columns to select
            if (config.columns) {
                let isIncludeMode = false;
                for (const [field, value] of Object.entries(config.columns)) {
                    if (value === undefined) {
                        continue;
                    }
                    if (field in tableConfig.columns) {
                        if (!isIncludeMode && value === true) {
                            isIncludeMode = true;
                        }
                        selectedColumns.push(field);
                    }
                }
                if (selectedColumns.length > 0) {
                    selectedColumns = isIncludeMode
                        ? selectedColumns.filter((c) => config.columns?.[c] === true)
                        : Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
                }
            }
            else {
                // Select all columns if selection is not specified
                selectedColumns = Object.keys(tableConfig.columns);
            }
            for (const field of selectedColumns) {
                const column = tableConfig.columns[field];
                fieldsSelection.push({ tsKey: field, value: column });
            }
            let selectedRelations = [];
            // Figure out which relations to select
            if (config.with) {
                selectedRelations = Object.entries(config.with)
                    .filter((entry) => !!entry[1])
                    .map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey] }));
            }
            let extras;
            // Figure out which extras to select
            if (config.extras) {
                extras = typeof config.extras === 'function'
                    ? config.extras(aliasedColumns, { sql: index$1.sql })
                    : config.extras;
                for (const [tsKey, value] of Object.entries(extras)) {
                    fieldsSelection.push({
                        tsKey,
                        value: index$1.mapColumnsInAliasedSQLToAlias(value, tableAlias),
                    });
                }
            }
            // Transform `fieldsSelection` into `selection`
            // `fieldsSelection` shouldn't be used after this point
            for (const { tsKey, value } of fieldsSelection) {
                selection.push({
                    dbKey: index$1.is(value, index$1.SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey].name,
                    tsKey,
                    field: index$1.is(value, index$1.Column) ? index$1.aliasedTableColumn(value, tableAlias) : value,
                    relationTableTsKey: undefined,
                    isJson: false,
                    selection: [],
                });
            }
            let orderByOrig = typeof config.orderBy === 'function'
                ? config.orderBy(aliasedColumns, index$1.getOrderByOperators())
                : config.orderBy ?? [];
            if (!Array.isArray(orderByOrig)) {
                orderByOrig = [orderByOrig];
            }
            orderBy = orderByOrig.map((orderByValue) => {
                if (index$1.is(orderByValue, index$1.Column)) {
                    return index$1.aliasedTableColumn(orderByValue, tableAlias);
                }
                return index$1.mapColumnsInSQLToAlias(orderByValue, tableAlias);
            });
            limit = config.limit;
            offset = config.offset;
            // Process all relations
            for (const { tsKey: selectedRelationTsKey, queryConfig: selectedRelationConfigValue, relation, } of selectedRelations) {
                const normalizedRelation = index$1.normalizeRelation(schema, tableNamesMap, relation);
                const relationTableName = relation.referencedTable[index$1.Table.Symbol.Name];
                const relationTableTsName = tableNamesMap[relationTableName];
                const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
                // const relationTable = schema[relationTableTsName]!;
                const joinOn = index$1.and(...normalizedRelation.fields.map((field, i) => index$1.eq(index$1.aliasedTableColumn(normalizedRelation.references[i], relationTableAlias), index$1.aliasedTableColumn(field, tableAlias))));
                const builtRelation = this.buildRelationalQuery({
                    fullSchema,
                    schema,
                    tableNamesMap,
                    table: fullSchema[relationTableTsName],
                    tableConfig: schema[relationTableTsName],
                    queryConfig: index$1.is(relation, index$1.One)
                        ? (selectedRelationConfigValue === true
                            ? { limit: 1 }
                            : { ...selectedRelationConfigValue, limit: 1 })
                        : selectedRelationConfigValue,
                    tableAlias: relationTableAlias,
                    joinOn,
                    nestedQueryRelation: relation,
                });
                const field = (index$1.sql `(${builtRelation.sql})`).as(selectedRelationTsKey);
                selection.push({
                    dbKey: selectedRelationTsKey,
                    tsKey: selectedRelationTsKey,
                    field,
                    relationTableTsKey: relationTableTsName,
                    isJson: true,
                    selection: builtRelation.selection,
                });
            }
        }
        if (selection.length === 0) {
            throw new index$1.DrizzleError(`No fields selected for table "${tableConfig.tsName}" ("${tableAlias}"). You need to have at least one item in "columns", "with" or "extras". If you need to select all columns, omit the "columns" key or set it to undefined.`);
        }
        let result;
        where = index$1.and(joinOn, where);
        if (nestedQueryRelation) {
            let field = index$1.sql `json_array(${index$1.sql.join(selection.map(({ field }) => index$1.is(field, SQLiteColumn) ? index$1.sql.identifier(field.name) : index$1.is(field, index$1.SQL.Aliased) ? field.sql : field), index$1.sql `, `)})`;
            if (index$1.is(nestedQueryRelation, index$1.Many)) {
                field = index$1.sql `coalesce(json_group_array(${field}), json_array())`;
            }
            const nestedSelection = [{
                    dbKey: 'data',
                    tsKey: 'data',
                    field: field.as('data'),
                    isJson: true,
                    relationTableTsKey: tableConfig.tsName,
                    selection,
                }];
            const needsSubquery = limit !== undefined || offset !== undefined || orderBy.length > 0;
            if (needsSubquery) {
                result = this.buildSelectQuery({
                    table: index$1.aliasedTable(table, tableAlias),
                    fields: {},
                    fieldsFlat: [
                        {
                            path: [],
                            field: index$1.sql.raw('*'),
                        },
                    ],
                    where,
                    limit,
                    offset,
                    orderBy,
                });
                where = undefined;
                limit = undefined;
                offset = undefined;
                orderBy = undefined;
            }
            else {
                result = index$1.aliasedTable(table, tableAlias);
            }
            result = this.buildSelectQuery({
                table: index$1.is(result, SQLiteTable) ? result : new index$1.Subquery(result, {}, tableAlias),
                fields: {},
                fieldsFlat: nestedSelection.map(({ field }) => ({
                    path: [],
                    field: index$1.is(field, index$1.Column) ? index$1.aliasedTableColumn(field, tableAlias) : field,
                })),
                joins,
                where,
                limit,
                offset,
                orderBy,
            });
        }
        else {
            result = this.buildSelectQuery({
                table: index$1.aliasedTable(table, tableAlias),
                fields: {},
                fieldsFlat: selection.map(({ field }) => ({
                    path: [],
                    field: index$1.is(field, index$1.Column) ? index$1.aliasedTableColumn(field, tableAlias) : field,
                })),
                joins,
                where,
                limit,
                offset,
                orderBy,
            });
        }
        return {
            tableTsKey: tableConfig.tsName,
            sql: result,
            selection,
        };
    }
}
_a$9 = index$1.entityKind;
SQLiteDialect[_a$9] = 'SQLiteDialect';
class SQLiteSyncDialect extends SQLiteDialect {
    migrate(migrations, session) {
        const migrationTableCreate = index$1.sql `
			CREATE TABLE IF NOT EXISTS "__drizzle_migrations" (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at numeric
			)
		`;
        session.run(migrationTableCreate);
        const dbMigrations = session.values(index$1.sql `SELECT id, hash, created_at FROM "__drizzle_migrations" ORDER BY created_at DESC LIMIT 1`);
        const lastDbMigration = dbMigrations[0] ?? undefined;
        session.run(index$1.sql `BEGIN`);
        try {
            for (const migration of migrations) {
                if (!lastDbMigration || Number(lastDbMigration[2]) < migration.folderMillis) {
                    for (const stmt of migration.sql) {
                        session.run(index$1.sql.raw(stmt));
                    }
                    session.run(index$1.sql `INSERT INTO "__drizzle_migrations" ("hash", "created_at") VALUES(${migration.hash}, ${migration.folderMillis})`);
                }
            }
            session.run(index$1.sql `COMMIT`);
        }
        catch (e) {
            session.run(index$1.sql `ROLLBACK`);
            throw e;
        }
    }
}
_b$7 = index$1.entityKind;
SQLiteSyncDialect[_b$7] = 'SQLiteSyncDialect';
class SQLiteAsyncDialect extends SQLiteDialect {
    async migrate(migrations, session) {
        const migrationTableCreate = index$1.sql `
			CREATE TABLE IF NOT EXISTS "__drizzle_migrations" (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at numeric
			)
		`;
        await session.run(migrationTableCreate);
        const dbMigrations = await session.values(index$1.sql `SELECT id, hash, created_at FROM "__drizzle_migrations" ORDER BY created_at DESC LIMIT 1`);
        const lastDbMigration = dbMigrations[0] ?? undefined;
        await session.transaction(async (tx) => {
            for (const migration of migrations) {
                if (!lastDbMigration || Number(lastDbMigration[2]) < migration.folderMillis) {
                    for (const stmt of migration.sql) {
                        await tx.run(index$1.sql.raw(stmt));
                    }
                    await tx.run(index$1.sql `INSERT INTO "__drizzle_migrations" ("hash", "created_at") VALUES(${migration.hash}, ${migration.folderMillis})`);
                }
            }
        });
    }
}
_c$4 = index$1.entityKind;
SQLiteAsyncDialect[_c$4] = 'SQLiteAsyncDialect';

var _a$8, _b$6, _c$3;
class SQLiteSelectBuilder {
    constructor(config) {
        this.fields = config.fields;
        this.session = config.session;
        this.dialect = config.dialect;
        this.withList = config.withList;
        this.distinct = config.distinct;
    }
    from(source) {
        const isPartialSelect = !!this.fields;
        let fields;
        if (this.fields) {
            fields = this.fields;
        }
        else if (index$1.is(source, index$1.Subquery)) {
            // This is required to use the proxy handler to get the correct field values from the subquery
            fields = Object.fromEntries(Object.keys(source[index$1.SubqueryConfig].selection).map((key) => [key, source[key]]));
        }
        else if (index$1.is(source, SQLiteViewBase)) {
            fields = source[index$1.ViewBaseConfig].selectedFields;
        }
        else if (index$1.is(source, index$1.SQL)) {
            fields = {};
        }
        else {
            fields = index$1.getTableColumns(source);
        }
        return new SQLiteSelect({
            table: source,
            fields,
            isPartialSelect,
            session: this.session,
            dialect: this.dialect,
            withList: this.withList,
            distinct: this.distinct,
        });
    }
}
_a$8 = index$1.entityKind;
SQLiteSelectBuilder[_a$8] = 'SQLiteSelectBuilder';
class SQLiteSelectQueryBuilder extends index$1.TypedQueryBuilder {
    constructor({ table, fields, isPartialSelect, session, dialect, withList, distinct }) {
        super();
        this.leftJoin = this.createJoin('left');
        this.rightJoin = this.createJoin('right');
        this.innerJoin = this.createJoin('inner');
        this.fullJoin = this.createJoin('full');
        this.config = {
            withList,
            table,
            fields: { ...fields },
            distinct,
        };
        this.isPartialSelect = isPartialSelect;
        this.session = session;
        this.dialect = dialect;
        this._ = {
            selectedFields: fields,
        };
        this.tableName = index$1.getTableLikeName(table);
        this.joinsNotNullableMap = typeof this.tableName === 'string' ? { [this.tableName]: true } : {};
    }
    createJoin(joinType) {
        return (table, on) => {
            const baseTableName = this.tableName;
            const tableName = index$1.getTableLikeName(table);
            if (typeof tableName === 'string' && this.config.joins?.some((join) => join.alias === tableName)) {
                throw new Error(`Alias "${tableName}" is already used in this query`);
            }
            if (!this.isPartialSelect) {
                // If this is the first join and this is not a partial select and we're not selecting from raw SQL, "move" the fields from the main table to the nested object
                if (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === 'string') {
                    this.config.fields = {
                        [baseTableName]: this.config.fields,
                    };
                }
                if (typeof tableName === 'string' && !index$1.is(table, index$1.SQL)) {
                    const selection = index$1.is(table, index$1.Subquery)
                        ? table[index$1.SubqueryConfig].selection
                        : index$1.is(table, index$1.View)
                            ? table[index$1.ViewBaseConfig].selectedFields
                            : table[index$1.Table.Symbol.Columns];
                    this.config.fields[tableName] = selection;
                }
            }
            if (typeof on === 'function') {
                on = on(new Proxy(this.config.fields, new index$1.SelectionProxyHandler({ sqlAliasedBehavior: 'sql', sqlBehavior: 'sql' })));
            }
            if (!this.config.joins) {
                this.config.joins = [];
            }
            this.config.joins.push({ on, table, joinType, alias: tableName });
            if (typeof tableName === 'string') {
                switch (joinType) {
                    case 'left': {
                        this.joinsNotNullableMap[tableName] = false;
                        break;
                    }
                    case 'right': {
                        this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
                        this.joinsNotNullableMap[tableName] = true;
                        break;
                    }
                    case 'inner': {
                        this.joinsNotNullableMap[tableName] = true;
                        break;
                    }
                    case 'full': {
                        this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
                        this.joinsNotNullableMap[tableName] = false;
                        break;
                    }
                }
            }
            return this;
        };
    }
    where(where) {
        if (typeof where === 'function') {
            where = where(new Proxy(this.config.fields, new index$1.SelectionProxyHandler({ sqlAliasedBehavior: 'sql', sqlBehavior: 'sql' })));
        }
        this.config.where = where;
        return this;
    }
    having(having) {
        if (typeof having === 'function') {
            having = having(new Proxy(this.config.fields, new index$1.SelectionProxyHandler({ sqlAliasedBehavior: 'sql', sqlBehavior: 'sql' })));
        }
        this.config.having = having;
        return this;
    }
    groupBy(...columns) {
        if (typeof columns[0] === 'function') {
            const groupBy = columns[0](new Proxy(this.config.fields, new index$1.SelectionProxyHandler({ sqlAliasedBehavior: 'alias', sqlBehavior: 'sql' })));
            this.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];
        }
        else {
            this.config.groupBy = columns;
        }
        return this;
    }
    orderBy(...columns) {
        if (typeof columns[0] === 'function') {
            const orderBy = columns[0](new Proxy(this.config.fields, new index$1.SelectionProxyHandler({ sqlAliasedBehavior: 'alias', sqlBehavior: 'sql' })));
            this.config.orderBy = Array.isArray(orderBy) ? orderBy : [orderBy];
        }
        else {
            this.config.orderBy = columns;
        }
        return this;
    }
    limit(limit) {
        this.config.limit = limit;
        return this;
    }
    offset(offset) {
        this.config.offset = offset;
        return this;
    }
    /** @internal */
    getSQL() {
        return this.dialect.buildSelectQuery(this.config);
    }
    toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
    }
    as(alias) {
        return new Proxy(new index$1.Subquery(this.getSQL(), this.config.fields, alias), new index$1.SelectionProxyHandler({ alias, sqlAliasedBehavior: 'alias', sqlBehavior: 'error' }));
    }
    getSelectedFields() {
        return new Proxy(this.config.fields, new index$1.SelectionProxyHandler({ alias: this.tableName, sqlAliasedBehavior: 'alias', sqlBehavior: 'error' }));
    }
}
_b$6 = index$1.entityKind;
SQLiteSelectQueryBuilder[_b$6] = 'SQLiteSelectQueryBuilder';
class SQLiteSelect extends SQLiteSelectQueryBuilder {
    constructor() {
        super(...arguments);
        this.run = (placeholderValues) => {
            return this.prepare(true).run(placeholderValues);
        };
        this.all = (placeholderValues) => {
            return this.prepare(true).all(placeholderValues);
        };
        this.get = (placeholderValues) => {
            return this.prepare(true).get(placeholderValues);
        };
        this.values = (placeholderValues) => {
            return this.prepare(true).values(placeholderValues);
        };
    }
    prepare(isOneTimeQuery) {
        if (!this.session) {
            throw new Error('Cannot execute a query on a query builder. Please use a database instance instead.');
        }
        const fieldsList = index$1.orderSelectedFields(this.config.fields);
        const query = this.session[isOneTimeQuery ? 'prepareOneTimeQuery' : 'prepareQuery'](this.dialect.sqlToQuery(this.getSQL()), fieldsList, 'all');
        query.joinsNotNullableMap = this.joinsNotNullableMap;
        return query;
    }
    async execute() {
        return this.all();
    }
}
_c$3 = index$1.entityKind;
SQLiteSelect[_c$3] = 'SQLiteSelect';
index$1.applyMixins(SQLiteSelect, [index$1.QueryPromise]);

var _a$7;
class QueryBuilder {
    $with(alias) {
        const queryBuilder = this;
        return {
            as(qb) {
                if (typeof qb === 'function') {
                    qb = qb(queryBuilder);
                }
                return new Proxy(new index$1.WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true), new index$1.SelectionProxyHandler({ alias, sqlAliasedBehavior: 'alias', sqlBehavior: 'error' }));
            },
        };
    }
    with(...queries) {
        const self = this;
        function select(fields) {
            return new SQLiteSelectBuilder({
                fields: fields ?? undefined,
                session: undefined,
                dialect: self.getDialect(),
                withList: queries,
            });
        }
        function selectDistinct(fields) {
            return new SQLiteSelectBuilder({
                fields: fields ?? undefined,
                session: undefined,
                dialect: self.getDialect(),
                withList: queries,
                distinct: true,
            });
        }
        return { select, selectDistinct };
    }
    select(fields) {
        return new SQLiteSelectBuilder({ fields: fields ?? undefined, session: undefined, dialect: this.getDialect() });
    }
    selectDistinct(fields) {
        return new SQLiteSelectBuilder({
            fields: fields ?? undefined,
            session: undefined,
            dialect: this.getDialect(),
            distinct: true,
        });
    }
    // Lazy load dialect to avoid circular dependency
    getDialect() {
        if (!this.dialect) {
            this.dialect = new SQLiteSyncDialect();
        }
        return this.dialect;
    }
}
_a$7 = index$1.entityKind;
QueryBuilder[_a$7] = 'SQLiteQueryBuilder';

var _a$6, _b$5;
class SQLiteUpdateBuilder {
    constructor(table, session, dialect) {
        this.table = table;
        this.session = session;
        this.dialect = dialect;
    }
    set(values) {
        return new SQLiteUpdate(this.table, index$1.mapUpdateSet(this.table, values), this.session, this.dialect);
    }
}
_a$6 = index$1.entityKind;
SQLiteUpdateBuilder[_a$6] = 'SQLiteUpdateBuilder';
class SQLiteUpdate extends index$1.QueryPromise {
    constructor(table, set, session, dialect) {
        super();
        this.session = session;
        this.dialect = dialect;
        this.run = (placeholderValues) => {
            return this.prepare(true).run(placeholderValues);
        };
        this.all = (placeholderValues) => {
            return this.prepare(true).all(placeholderValues);
        };
        this.get = (placeholderValues) => {
            return this.prepare(true).get(placeholderValues);
        };
        this.values = (placeholderValues) => {
            return this.prepare(true).values(placeholderValues);
        };
        this.config = { set, table };
    }
    where(where) {
        this.config.where = where;
        return this;
    }
    returning(fields = this.config.table[SQLiteTable.Symbol.Columns]) {
        this.config.returning = index$1.orderSelectedFields(fields);
        return this;
    }
    /** @internal */
    getSQL() {
        return this.dialect.buildUpdateQuery(this.config);
    }
    toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
    }
    prepare(isOneTimeQuery) {
        return this.session[isOneTimeQuery ? 'prepareOneTimeQuery' : 'prepareQuery'](this.dialect.sqlToQuery(this.getSQL()), this.config.returning, this.config.returning ? 'all' : 'run');
    }
    async execute() {
        return (this.config.returning ? this.all() : this.run());
    }
}
_b$5 = index$1.entityKind;
SQLiteUpdate[_b$5] = 'SQLiteUpdate';

var _a$5, _b$4, _c$2;
class RelationalQueryBuilder {
    constructor(mode, fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session) {
        this.mode = mode;
        this.fullSchema = fullSchema;
        this.schema = schema;
        this.tableNamesMap = tableNamesMap;
        this.table = table;
        this.tableConfig = tableConfig;
        this.dialect = dialect;
        this.session = session;
    }
    findMany(config) {
        return (this.mode === 'sync'
            ? new SQLiteSyncRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? config : {}, 'many')
            : new SQLiteRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? config : {}, 'many'));
    }
    findFirst(config) {
        return (this.mode === 'sync'
            ? new SQLiteSyncRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? { ...config, limit: 1 } : { limit: 1 }, 'first')
            : new SQLiteRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? { ...config, limit: 1 } : { limit: 1 }, 'first'));
    }
}
_a$5 = index$1.entityKind;
RelationalQueryBuilder[_a$5] = 'SQLiteAsyncRelationalQueryBuilder';
class SQLiteRelationalQuery extends index$1.QueryPromise {
    constructor(fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session, config, mode) {
        super();
        this.fullSchema = fullSchema;
        this.schema = schema;
        this.tableNamesMap = tableNamesMap;
        this.table = table;
        this.tableConfig = tableConfig;
        this.dialect = dialect;
        this.session = session;
        this.config = config;
        this.mode = mode;
    }
    prepare() {
        const query = this.dialect.buildRelationalQuery({
            fullSchema: this.fullSchema,
            schema: this.schema,
            tableNamesMap: this.tableNamesMap,
            table: this.table,
            tableConfig: this.tableConfig,
            queryConfig: this.config,
            tableAlias: this.tableConfig.tsName,
        });
        const builtQuery = this.dialect.sqlToQuery(query.sql);
        return this.session.prepareQuery(builtQuery, undefined, this.mode === 'first' ? 'get' : 'all', (rawRows, mapColumnValue) => {
            const rows = rawRows.map((row) => index$1.mapRelationalRow(this.schema, this.tableConfig, row, query.selection, mapColumnValue));
            if (this.mode === 'first') {
                return rows[0];
            }
            return rows;
        });
    }
    /** @internal */
    executeRaw() {
        if (this.mode === 'first') {
            return this.prepare().get();
        }
        return this.prepare().all();
    }
    async execute() {
        return this.executeRaw();
    }
}
_b$4 = index$1.entityKind;
SQLiteRelationalQuery[_b$4] = 'SQLiteAsyncRelationalQuery';
class SQLiteSyncRelationalQuery extends SQLiteRelationalQuery {
    sync() {
        return this.executeRaw();
    }
}
_c$2 = index$1.entityKind;
SQLiteSyncRelationalQuery[_c$2] = 'SQLiteSyncRelationalQuery';

var _a$4;
class BaseSQLiteDatabase {
    constructor(resultKind, 
    /** @internal */
    dialect, 
    /** @internal */
    session, schema) {
        this.dialect = dialect;
        this.session = session;
        this._ = schema
            ? { schema: schema.schema, tableNamesMap: schema.tableNamesMap }
            : { schema: undefined, tableNamesMap: {} };
        this.query = {};
        if (this._.schema) {
            for (const [tableName, columns] of Object.entries(this._.schema)) {
                this.query[tableName] = new RelationalQueryBuilder(resultKind, schema.fullSchema, this._.schema, this._.tableNamesMap, schema.fullSchema[tableName], columns, dialect, session);
            }
        }
    }
    $with(alias) {
        return {
            as(qb) {
                if (typeof qb === 'function') {
                    qb = qb(new QueryBuilder());
                }
                return new Proxy(new index$1.WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true), new index$1.SelectionProxyHandler({ alias, sqlAliasedBehavior: 'alias', sqlBehavior: 'error' }));
            },
        };
    }
    with(...queries) {
        const self = this;
        function select(fields) {
            return new SQLiteSelectBuilder({
                fields: fields ?? undefined,
                session: self.session,
                dialect: self.dialect,
                withList: queries,
            });
        }
        function selectDistinct(fields) {
            return new SQLiteSelectBuilder({
                fields: fields ?? undefined,
                session: self.session,
                dialect: self.dialect,
                withList: queries,
                distinct: true,
            });
        }
        return { select, selectDistinct };
    }
    select(fields) {
        return new SQLiteSelectBuilder({ fields: fields ?? undefined, session: this.session, dialect: this.dialect });
    }
    selectDistinct(fields) {
        return new SQLiteSelectBuilder({
            fields: fields ?? undefined,
            session: this.session,
            dialect: this.dialect,
            distinct: true,
        });
    }
    update(table) {
        return new SQLiteUpdateBuilder(table, this.session, this.dialect);
    }
    insert(into) {
        return new SQLiteInsertBuilder(into, this.session, this.dialect);
    }
    delete(from) {
        return new SQLiteDelete(from, this.session, this.dialect);
    }
    run(query) {
        return this.session.run(query.getSQL());
    }
    all(query) {
        return this.session.all(query.getSQL());
    }
    get(query) {
        return this.session.get(query.getSQL());
    }
    values(query) {
        return this.session.values(query.getSQL());
    }
    transaction(transaction, config) {
        return this.session.transaction(transaction, config);
    }
}
_a$4 = index$1.entityKind;
BaseSQLiteDatabase[_a$4] = 'BaseSQLiteDatabase';

var _a$3, _b$3;
class CheckBuilder {
    constructor(name, value) {
        this.name = name;
        this.value = value;
    }
    build(table) {
        return new Check(table, this);
    }
}
_a$3 = index$1.entityKind;
CheckBuilder[_a$3] = 'SQLiteCheckBuilder';
class Check {
    constructor(table, builder) {
        this.table = table;
        this.name = builder.name;
        this.value = builder.value;
    }
}
_b$3 = index$1.entityKind;
Check[_b$3] = 'SQLiteCheck';
function check(name, value) {
    return new CheckBuilder(name, value);
}

var _a$2, _b$2, _c$1;
class IndexBuilderOn {
    constructor(name, unique) {
        this.name = name;
        this.unique = unique;
    }
    on(...columns) {
        return new IndexBuilder(this.name, columns, this.unique);
    }
}
_a$2 = index$1.entityKind;
IndexBuilderOn[_a$2] = 'SQLiteIndexBuilderOn';
class IndexBuilder {
    constructor(name, columns, unique) {
        this.config = {
            name,
            columns,
            unique,
            where: undefined,
        };
    }
    /**
     * Condition for partial index.
     */
    where(condition) {
        this.config.where = condition;
        return this;
    }
    /** @internal */
    build(table) {
        return new Index(this.config, table);
    }
}
_b$2 = index$1.entityKind;
IndexBuilder[_b$2] = 'SQLiteIndexBuilder';
class Index {
    constructor(config, table) {
        this.config = { ...config, table };
    }
}
_c$1 = index$1.entityKind;
Index[_c$1] = 'SQLiteIndex';
function index(name) {
    return new IndexBuilderOn(name, false);
}
function uniqueIndex(name) {
    return new IndexBuilderOn(name, true);
}

var _a$1, _b$1;
function primaryKey(...columns) {
    return new PrimaryKeyBuilder(columns);
}
class PrimaryKeyBuilder {
    constructor(columns) {
        this.columns = columns;
    }
    /** @internal */
    build(table) {
        return new PrimaryKey(table, this.columns);
    }
}
_a$1 = index$1.entityKind;
PrimaryKeyBuilder[_a$1] = 'SQLitePrimaryKeyBuilder';
class PrimaryKey {
    constructor(table, columns) {
        this.table = table;
        this.columns = columns;
    }
    getName() {
        return `${this.table[SQLiteTable.Symbol.Name]}_${this.columns.map((column) => column.name).join('_')}_pk`;
    }
}
_b$1 = index$1.entityKind;
PrimaryKey[_b$1] = 'SQLitePrimaryKey';

var _a, _b, _c, _d;
class ExecuteResultSync extends index$1.QueryPromise {
    constructor(resultCb) {
        super();
        this.resultCb = resultCb;
    }
    async execute() {
        return this.resultCb();
    }
    sync() {
        return this.resultCb();
    }
}
_a = index$1.entityKind;
ExecuteResultSync[_a] = 'ExecuteResultSync';
let PreparedQuery$1 = class PreparedQuery {
    constructor(mode, executeMethod) {
        this.mode = mode;
        this.executeMethod = executeMethod;
    }
    execute(placeholderValues) {
        if (this.mode === 'async') {
            return this[this.executeMethod](placeholderValues);
        }
        return new ExecuteResultSync(() => this[this.executeMethod](placeholderValues));
    }
};
_b = index$1.entityKind;
PreparedQuery$1[_b] = 'PreparedQuery';
class SQLiteSession {
    constructor(
    /** @internal */
    dialect) {
        this.dialect = dialect;
    }
    prepareOneTimeQuery(query, fields, executeMethod) {
        return this.prepareQuery(query, fields, executeMethod);
    }
    run(query) {
        const staticQuery = this.dialect.sqlToQuery(query);
        try {
            return this.prepareOneTimeQuery(staticQuery, undefined, 'run').run();
        }
        catch (err) {
            throw index$1.DrizzleError.wrap(err, `Failed to run the query '${staticQuery.sql}'`);
        }
    }
    all(query) {
        return this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), undefined, 'run').all();
    }
    get(query) {
        return this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), undefined, 'run').get();
    }
    values(query) {
        return this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), undefined, 'run').values();
    }
}
_c = index$1.entityKind;
SQLiteSession[_c] = 'SQLiteSession';
class SQLiteTransaction extends BaseSQLiteDatabase {
    constructor(resultType, dialect, session, schema, nestedIndex = 0) {
        super(resultType, dialect, session, schema);
        this.schema = schema;
        this.nestedIndex = nestedIndex;
    }
    rollback() {
        throw new index$1.TransactionRollbackError();
    }
}
_d = index$1.entityKind;
SQLiteTransaction[_d] = 'SQLiteTransaction';

exports.BaseSQLiteDatabase = BaseSQLiteDatabase;
exports.Check = Check;
exports.CheckBuilder = CheckBuilder;
exports.ExecuteResultSync = ExecuteResultSync;
exports.ForeignKey = ForeignKey;
exports.ForeignKeyBuilder = ForeignKeyBuilder;
exports.Index = Index;
exports.IndexBuilder = IndexBuilder;
exports.IndexBuilderOn = IndexBuilderOn;
exports.InlineForeignKeys = InlineForeignKeys;
exports.ManualViewBuilder = ManualViewBuilder;
exports.PreparedQuery = PreparedQuery$1;
exports.PrimaryKey = PrimaryKey;
exports.PrimaryKeyBuilder = PrimaryKeyBuilder;
exports.QueryBuilder = QueryBuilder;
exports.SQLiteAsyncDialect = SQLiteAsyncDialect;
exports.SQLiteBaseInteger = SQLiteBaseInteger;
exports.SQLiteBaseIntegerBuilder = SQLiteBaseIntegerBuilder;
exports.SQLiteBigInt = SQLiteBigInt;
exports.SQLiteBigIntBuilder = SQLiteBigIntBuilder;
exports.SQLiteBlobBuffer = SQLiteBlobBuffer;
exports.SQLiteBlobBufferBuilder = SQLiteBlobBufferBuilder;
exports.SQLiteBlobJson = SQLiteBlobJson;
exports.SQLiteBlobJsonBuilder = SQLiteBlobJsonBuilder;
exports.SQLiteBoolean = SQLiteBoolean;
exports.SQLiteBooleanBuilder = SQLiteBooleanBuilder;
exports.SQLiteColumn = SQLiteColumn;
exports.SQLiteColumnBuilder = SQLiteColumnBuilder;
exports.SQLiteCustomColumn = SQLiteCustomColumn;
exports.SQLiteCustomColumnBuilder = SQLiteCustomColumnBuilder;
exports.SQLiteDelete = SQLiteDelete;
exports.SQLiteDialect = SQLiteDialect;
exports.SQLiteInsert = SQLiteInsert;
exports.SQLiteInsertBuilder = SQLiteInsertBuilder;
exports.SQLiteInteger = SQLiteInteger;
exports.SQLiteIntegerBuilder = SQLiteIntegerBuilder;
exports.SQLiteNumeric = SQLiteNumeric;
exports.SQLiteNumericBuilder = SQLiteNumericBuilder;
exports.SQLiteReal = SQLiteReal;
exports.SQLiteRealBuilder = SQLiteRealBuilder;
exports.SQLiteSelect = SQLiteSelect;
exports.SQLiteSelectBuilder = SQLiteSelectBuilder;
exports.SQLiteSelectQueryBuilder = SQLiteSelectQueryBuilder;
exports.SQLiteSession = SQLiteSession;
exports.SQLiteSyncDialect = SQLiteSyncDialect;
exports.SQLiteTable = SQLiteTable;
exports.SQLiteText = SQLiteText;
exports.SQLiteTextBuilder = SQLiteTextBuilder;
exports.SQLiteTimestamp = SQLiteTimestamp;
exports.SQLiteTimestampBuilder = SQLiteTimestampBuilder;
exports.SQLiteTransaction = SQLiteTransaction;
exports.SQLiteUpdate = SQLiteUpdate;
exports.SQLiteUpdateBuilder = SQLiteUpdateBuilder;
exports.SQLiteView = SQLiteView;
exports.SQLiteViewBase = SQLiteViewBase;
exports.SQLiteViewConfig = SQLiteViewConfig;
exports.UniqueConstraint = UniqueConstraint;
exports.UniqueConstraintBuilder = UniqueConstraintBuilder;
exports.UniqueOnConstraintBuilder = UniqueOnConstraintBuilder;
exports.ViewBuilder = ViewBuilder;
exports.ViewBuilderCore = ViewBuilderCore;
exports.blob = blob;
exports.check = check;
exports.customType = customType;
exports.foreignKey = foreignKey;
exports.index = index;
exports.int = int;
exports.integer = integer;
exports.numeric = numeric;
exports.primaryKey = primaryKey;
exports.real = real;
exports.sqliteTable = sqliteTable;
exports.sqliteTableCreator = sqliteTableCreator;
exports.sqliteView = sqliteView;
exports.text = text;
exports.unique = unique;
exports.uniqueIndex = uniqueIndex;
exports.uniqueKeyName = uniqueKeyName;
exports.view = view;
//# sourceMappingURL=session-fadbb086.cjs.map
