import { entityKind } from '../../entity.js';
import type { SelectResultFields } from '../../query-builders/select.types.js';
import { QueryPromise } from '../../query-promise.js';
import type { Placeholder, Query, SQLWrapper } from '../../sql/index.js';
import { Param, SQL } from '../../sql/index.js';
import type { SQLiteDialect } from '../dialect.js';
import type { IndexColumn } from '../indexes.js';
import type { PreparedQuery, SQLiteSession } from '../session.js';
import { SQLiteTable } from '../table.js';
import { type InferModel } from '../../table.js';
import { type DrizzleTypeError, type Simplify } from '../../utils.js';
import type { SelectedFieldsFlat, SelectedFieldsOrdered } from './select.types.js';
import type { SQLiteUpdateSetSource } from './update.js';
export interface SQLiteInsertConfig<TTable extends SQLiteTable = SQLiteTable> {
    table: TTable;
    values: Record<string, Param | SQL>[];
    onConflict?: SQL;
    returning?: SelectedFieldsOrdered;
}
export type SQLiteInsertValue<TTable extends SQLiteTable> = Simplify<{
    [Key in keyof InferModel<TTable, 'insert'>]: InferModel<TTable, 'insert'>[Key] | SQL | Placeholder;
}>;
export declare class SQLiteInsertBuilder<TTable extends SQLiteTable, TResultType extends 'sync' | 'async', TRunResult> {
    protected table: TTable;
    protected session: SQLiteSession<any, any, any, any>;
    protected dialect: SQLiteDialect;
    static readonly [entityKind]: string;
    constructor(table: TTable, session: SQLiteSession<any, any, any, any>, dialect: SQLiteDialect);
    values(value: SQLiteInsertValue<TTable>): SQLiteInsert<TTable, TResultType, TRunResult>;
    values(values: SQLiteInsertValue<TTable>[]): SQLiteInsert<TTable, TResultType, TRunResult>;
}
export interface SQLiteInsert<TTable extends SQLiteTable, TResultType extends 'sync' | 'async', TRunResult, TReturning = undefined> extends SQLWrapper, QueryPromise<TReturning extends undefined ? TRunResult : TReturning[]> {
}
export declare class SQLiteInsert<TTable extends SQLiteTable, TResultType extends 'sync' | 'async', TRunResult, TReturning = undefined> extends QueryPromise<TReturning extends undefined ? TRunResult : TReturning[]> implements SQLWrapper {
    private session;
    private dialect;
    static readonly [entityKind]: string;
    readonly _: {
        readonly table: TTable;
        readonly resultType: TResultType;
        readonly runResult: TRunResult;
        readonly returning: TReturning;
    };
    private config;
    constructor(table: TTable, values: SQLiteInsertConfig['values'], session: SQLiteSession<any, any, any, any>, dialect: SQLiteDialect);
    returning(): SQLiteInsert<TTable, TResultType, TRunResult, InferModel<TTable>>;
    returning<TSelectedFields extends SelectedFieldsFlat>(fields: TSelectedFields): SQLiteInsert<TTable, TResultType, TRunResult, SelectResultFields<TSelectedFields>>;
    onConflictDoNothing(config?: {
        target?: IndexColumn | IndexColumn[];
        where?: SQL;
    }): this;
    onConflictDoUpdate(config: {
        target: IndexColumn | IndexColumn[];
        where?: SQL;
        set: SQLiteUpdateSetSource<TTable>;
    }): this;
    toSQL(): Simplify<{
        sql: Query['sql'];
        params: Query['params'];
    }>;
    prepare(isOneTimeQuery?: boolean): PreparedQuery<{
        type: TResultType;
        run: TRunResult;
        all: TReturning extends undefined ? DrizzleTypeError<'.all() cannot be used without .returning()'> : TReturning[];
        get: TReturning extends undefined ? DrizzleTypeError<'.get() cannot be used without .returning()'> : TReturning;
        values: TReturning extends undefined ? DrizzleTypeError<'.values() cannot be used without .returning()'> : any[][];
        execute: TReturning extends undefined ? TRunResult : TReturning[];
    }>;
    run: ReturnType<this['prepare']>['run'];
    all: ReturnType<this['prepare']>['all'];
    get: ReturnType<this['prepare']>['get'];
    values: ReturnType<this['prepare']>['values'];
    execute(): Promise<TReturning extends undefined ? TRunResult : TReturning[]>;
}
