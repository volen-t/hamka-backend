import { entityKind } from '../../entity.js';
import type { PgDialect } from '../dialect.js';
import type { IndexColumn } from '../indexes.js';
import type { PgSession, PreparedQuery, PreparedQueryConfig, QueryResultHKT, QueryResultKind } from '../session.js';
import type { PgTable } from '../table.js';
import type { SelectResultFields } from '../../query-builders/select.types.js';
import { QueryPromise } from '../../query-promise.js';
import type { Placeholder, Query, SQLWrapper } from '../../sql/index.js';
import { Param, SQL } from '../../sql/index.js';
import { type InferModel } from '../../table.js';
import type { SelectedFieldsFlat, SelectedFieldsOrdered } from './select.types.js';
import type { PgUpdateSetSource } from './update.js';
export interface PgInsertConfig<TTable extends PgTable = PgTable> {
    table: TTable;
    values: Record<string, Param | SQL>[];
    onConflict?: SQL;
    returning?: SelectedFieldsOrdered;
}
export type PgInsertValue<TTable extends PgTable> = {
    [Key in keyof InferModel<TTable, 'insert'>]: InferModel<TTable, 'insert'>[Key] | SQL | Placeholder;
} & {};
export declare class PgInsertBuilder<TTable extends PgTable, TQueryResult extends QueryResultHKT> {
    private table;
    private session;
    private dialect;
    static readonly [entityKind]: string;
    constructor(table: TTable, session: PgSession, dialect: PgDialect);
    values(value: PgInsertValue<TTable>): PgInsert<TTable, TQueryResult>;
    values(values: PgInsertValue<TTable>[]): PgInsert<TTable, TQueryResult>;
}
export interface PgInsert<TTable extends PgTable, TQueryResult extends QueryResultHKT, TReturning extends Record<string, unknown> | undefined = undefined> extends QueryPromise<TReturning extends undefined ? QueryResultKind<TQueryResult, never> : TReturning[]>, SQLWrapper {
}
export declare class PgInsert<TTable extends PgTable, TQueryResult extends QueryResultHKT, TReturning extends Record<string, unknown> | undefined = undefined> extends QueryPromise<TReturning extends undefined ? QueryResultKind<TQueryResult, never> : TReturning[]> implements SQLWrapper {
    private session;
    private dialect;
    static readonly [entityKind]: string;
    _: {
        table: TTable;
        return: TReturning;
    };
    private config;
    constructor(table: TTable, values: PgInsertConfig['values'], session: PgSession, dialect: PgDialect);
    returning(): PgInsert<TTable, TQueryResult, InferModel<TTable>>;
    returning<TSelectedFields extends SelectedFieldsFlat>(fields: TSelectedFields): PgInsert<TTable, TQueryResult, SelectResultFields<TSelectedFields>>;
    onConflictDoNothing(config?: {
        target?: IndexColumn | IndexColumn[];
        where?: SQL;
    }): this;
    onConflictDoUpdate(config: {
        target: IndexColumn | IndexColumn[];
        where?: SQL;
        set: PgUpdateSetSource<TTable>;
    }): this;
    toSQL(): {
        sql: Query['sql'];
        params: Query['params'];
    };
    private _prepare;
    prepare(name: string): PreparedQuery<PreparedQueryConfig & {
        execute: TReturning extends undefined ? QueryResultKind<TQueryResult, never> : TReturning[];
    }>;
    execute: ReturnType<this['prepare']>['execute'];
}
