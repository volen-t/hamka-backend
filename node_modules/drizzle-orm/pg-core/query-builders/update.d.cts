import type { GetColumnData } from '../../column.js';
import { entityKind } from '../../entity.js';
import type { PgDialect } from '../dialect.js';
import type { PgSession, PreparedQuery, PreparedQueryConfig, QueryResultHKT, QueryResultKind } from '../session.js';
import type { PgTable } from '../table.js';
import type { SelectResultFields } from '../../query-builders/select.types.js';
import { QueryPromise } from '../../query-promise.js';
import type { Query, SQL, SQLWrapper } from '../../sql/index.js';
import { type InferModel } from '../../table.js';
import { type UpdateSet } from '../../utils.js';
import type { SelectedFields, SelectedFieldsOrdered } from './select.types.js';
export interface PgUpdateConfig {
    where?: SQL | undefined;
    set: UpdateSet;
    table: PgTable;
    returning?: SelectedFieldsOrdered;
}
export type PgUpdateSetSource<TTable extends PgTable> = {
    [Key in keyof TTable['_']['columns']]?: GetColumnData<TTable['_']['columns'][Key]> | SQL;
} & {};
export declare class PgUpdateBuilder<TTable extends PgTable, TQueryResult extends QueryResultHKT> {
    private table;
    private session;
    private dialect;
    static readonly [entityKind]: string;
    readonly _: {
        readonly table: TTable;
    };
    constructor(table: TTable, session: PgSession, dialect: PgDialect);
    set(values: PgUpdateSetSource<TTable>): PgUpdate<TTable, TQueryResult>;
}
export interface PgUpdate<TTable extends PgTable, TQueryResult extends QueryResultHKT, TReturning extends Record<string, unknown> | undefined = undefined> extends QueryPromise<TReturning extends undefined ? QueryResultKind<TQueryResult, never> : TReturning[]>, SQLWrapper {
}
export declare class PgUpdate<TTable extends PgTable, TQueryResult extends QueryResultHKT, TReturning extends Record<string, unknown> | undefined = undefined> extends QueryPromise<TReturning extends undefined ? QueryResultKind<TQueryResult, never> : TReturning[]> implements SQLWrapper {
    private session;
    private dialect;
    static readonly [entityKind]: string;
    readonly _: {
        readonly table: TTable;
        readonly return: TReturning;
    };
    private config;
    constructor(table: TTable, set: UpdateSet, session: PgSession, dialect: PgDialect);
    where(where: SQL | undefined): this;
    returning(): PgUpdate<TTable, TQueryResult, InferModel<TTable>>;
    returning<TSelectedFields extends SelectedFields>(fields: TSelectedFields): PgUpdate<TTable, TQueryResult, SelectResultFields<TSelectedFields>>;
    toSQL(): Omit<Query, 'typings'>;
    private _prepare;
    prepare(name: string): PreparedQuery<PreparedQueryConfig & {
        execute: TReturning extends undefined ? QueryResultKind<TQueryResult, never> : TReturning[];
    }>;
    execute: ReturnType<this['prepare']>['execute'];
}
